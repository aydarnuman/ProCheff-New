#!/usr/bin/env node

/**
 * Tasarƒ±m ƒ∞lkeleri ‚Äî ƒ∞dempotent G√ºncelleme Denetimi
 * 
 * Ama√ß: Mevcut tasarƒ±m rehberini bozmadan yalnƒ±z eksik alanlarƒ± tamamlamak
 * Neden: √áakƒ±≈üma ve drift riskini sƒ±fƒ±rlamak; kurumsal tutarlƒ±lƒ±ƒüƒ± korumak
 */

const fs = require('fs');
const path = require('path');

class DesignSystemAudit {
  constructor() {
    this.auditFile = path.join(__dirname, '../reports/design-drift-audit.json');
    this.currentPrinciples = {};
    this.proposedPrinciples = {};
    this.conflicts = [];
    this.gaps = [];
  }

  performAudit() {
    console.log('üîç Tasarƒ±m ƒ∞lkeleri Denetimi Ba≈ülatƒ±lƒ±yor...\n');

    try {
      // 1. Mevcut Tasarƒ±m ƒ∞lkelerini Envanter Et
      this.auditCurrentPrinciples();
      
      // 2. √áakƒ±≈üma Matrisi Olu≈ütur
      this.analyzeConflicts();
      
      // 3. Go/No-Go Kararƒ± Ver
      const decision = this.makeGoNoGoDecision();
      
      // 4. Rapor Olu≈ütur
      this.generateReport(decision);
      
      return decision;

    } catch (error) {
      console.error('‚ùå Denetim Hatasƒ±:', error.message);
      throw error;
    }
  }

  auditCurrentPrinciples() {
    console.log('üìä Mevcut Tasarƒ±m ƒ∞lkeleri Envanteri:\n');

    // Mevcut audit dosyasƒ±ndan principles'ƒ± oku (varsa)
    let existingPrinciples = {};
    try {
      if (fs.existsSync(this.auditFile)) {
        const existingAudit = JSON.parse(fs.readFileSync(this.auditFile, 'utf8'));
        if (existingAudit.currentPrinciples) {
          existingPrinciples = existingAudit.currentPrinciples;
          console.log('üìã Mevcut dosyadan principles okundu');
        }
      }
    } catch (error) {
      console.log('üìù Yeni principles olu≈üturuluyor...');
    }

    // Varsa mevcut principles'ƒ± kullan, yoksa default set
    this.currentPrinciples = Object.keys(existingPrinciples).length > 0 ? existingPrinciples : {
      // Default principles (fallback)
      colorSystem: {
        primary: 'Emerald (emerald-400, emerald-500, emerald-600)',
        secondary: 'Blue, Purple, Orange, Amber',
        backgrounds: 'Gray-900 (dark), Gray-50 (light), Gray-800 (cards)',
        text: 'White, Gray-300, Gray-600, Gray-900',
        borders: 'Gray-700 (dark), border colors via hsl vars',
        status: {
          success: 'Green/Emerald',
          warning: 'Yellow/Amber', 
          error: 'Red',
          info: 'Blue/Sky'
        }
      },

      // Typography (Inter font, heading scales)
      typography: {
        fontFamily: 'Inter (Google Fonts)',
        headings: 'text-3xl, text-2xl, text-xl, text-lg',
        body: 'text-sm, text-base',
        weight: 'font-bold, font-semibold, font-medium, font-normal'
      },

      // Spacing & Layout (Tailwind utilities)
      spacing: {
        containers: 'max-w-4xl, max-w-7xl mx-auto',
        padding: 'p-4, p-6, p-8',
        margins: 'mb-6, mb-8, mt-8',
        gaps: 'gap-4, gap-6, space-y-2, space-y-4'
      },

      // 4. Bile≈üen Tasarƒ±mƒ± (Card, Button, Progress vb.)
      components: {
        cards: {
          base: 'rounded-lg border bg-gray-800 shadow-xl',
          dark: 'border-gray-700',
          content: 'p-6 pt-0',
          header: 'p-6 space-y-1.5'
        },
        buttons: {
          primary: 'bg-emerald-600 hover:bg-emerald-700',
          secondary: 'bg-blue-600, bg-purple-600, bg-orange-600',
          text: 'text-white transition-colors',
          padding: 'px-4 py-2 rounded'
        },
        progress: {
          base: 'h-4 w-full overflow-hidden rounded-full bg-gray-200',
          indicator: 'bg-emerald-500 transition-all',
          risk: 'bg-emerald-500 (safe), bg-yellow-500 (medium), bg-red-500 (high)'
        },
        sliders: {
          track: 'h-2 w-full bg-gray-200 rounded-full',
          range: 'bg-emerald-500',
          thumb: 'h-5 w-5 rounded-full border-2 border-emerald-500 bg-white'
        }
      },

      // 5. Grid & Layout Patterns (Dashboard layouts)
      layout: {
        dashboard: 'grid gap-6 lg:grid-cols-3',
        cards: 'grid gap-4 sm:grid-cols-2 lg:grid-cols-4',
        responsive: 'min-h-screen bg-gray-50 p-6'
      },

      // 6. ƒ∞konografi & Emojiler (ProCheff AI tarzƒ±)
      iconography: {
        navigation: 'üßë‚Äçüç≥ (ProCheff), üìä (Menu), üè™ (Market), üìà (Dashboard)',
        status: '‚úÖ (success), ‚ö†Ô∏è (warning), ‚ùå (error), üü¢üü°üî¥ (risk levels)',
        categories: 'ü•ó (nutrition), üí∞ (finance), ‚úÖ (compliance)',
        actions: 'üîÑ (refresh), ‚è≥ (loading), üéØ (optimal)'
      },

      // 7. Interaction States (hover, focus, disabled)
      interactions: {
        hover: 'hover:bg-emerald-700, hover:shadow-md',
        focus: 'focus-visible:ring-2 focus-visible:ring-emerald-500',
        disabled: 'disabled:pointer-events-none disabled:opacity-50',
        transitions: 'transition-colors, transition-all'
      },

      // 8. Data Visualization (recharts, colors)
      dataViz: {
        charts: 'BarChart with ResponsiveContainer',
        colors: {
          protein: '#22c55e (green)',
          fat: '#f59e0b (amber)', 
          carb: '#3b82f6 (blue)'
        },
        tooltips: 'Custom formatters for percentages'
      },

      // 9. Response States (loading, empty, error)
      responseStates: {
        loading: '"‚è≥ Sim√ºlasyon √áalƒ±≈üƒ±yor...", loading state management',
        empty: '"Hen√ºz insight verisi yok. Sim√ºlasyon √ßalƒ±≈ütƒ±rƒ±n."',
        error: 'Console.error logging, try-catch patterns'
      },

      // 10. Content Tone (Turkish, professional)
      contentTone: {
        language: 'Turkish (tr)',
        style: 'Professional but friendly',
        terminology: 'ProCheff AI, Beslenme Dengesi, Risk Skoru, Teklif Fiyatƒ±',
        messaging: 'Clear status messages, actionable guidance'
      }
    };

    // Envanter √ßƒ±ktƒ±sƒ±
    console.log('‚úÖ Mevcut ƒ∞lkeler Envanter Edildi:');
    Object.keys(this.currentPrinciples).forEach(category => {
      const count = Object.keys(this.currentPrinciples[category]).length;
      const displayName = category.charAt(0).toUpperCase() + category.slice(1);
      console.log(`   ‚Ä¢ ${displayName}: ${count} rule`);
    });
    console.log();
  }

  analyzeConflicts() {
    console.log('üîç √áakƒ±≈üma Analizi:\n');

    // Bu a≈üamada √∂nerilen yeni ilkeler yoksa √ßakƒ±≈üma da yok
    const conflictMatrix = {
      colorSystem: { conflicts: 0, overlaps: [] },
      typography: { conflicts: 0, overlaps: [] },
      spacing: { conflicts: 0, overlaps: [] },
      components: { conflicts: 0, overlaps: [] },
      layout: { conflicts: 0, overlaps: [] },
      iconography: { conflicts: 0, overlaps: [] },
      interactions: { conflicts: 0, overlaps: [] },
      dataViz: { conflicts: 0, overlaps: [] },
      responseStates: { conflicts: 0, overlaps: [] },
      contentTone: { conflicts: 0, overlaps: [] }
    };

    this.conflicts = conflictMatrix;
    
    console.log('‚úÖ √áakƒ±≈üma Matrisi Temiz:');
    console.log('   ‚Ä¢ Yeniden tanƒ±m: 0');
    console.log('   ‚Ä¢ √áakƒ±≈üan kural: 0'); 
    console.log('   ‚Ä¢ √ñrt√º≈üen tanƒ±m: 0\n');
  }

  makeGoNoGoDecision() {
    console.log('üéØ Go/No-Go Analizi:\n');

    const criteria = {
      zeroConflicts: Object.values(this.conflicts).every(c => c.conflicts === 0),
      noRedefinition: true, // Hen√ºz yeni √∂neri yok
      singleSource: true,   // Mevcut yapƒ± tek kaynak prensibi uyguluyor
      namingConsistency: true, // Mevcut adlandƒ±rma tutarlƒ±
      corePreservation: true   // √áekirdek ilkeler korunuyor
    };

    const decision = {
      status: criteria.zeroConflicts && criteria.noRedefinition && 
              criteria.singleSource && criteria.namingConsistency && 
              criteria.corePreservation ? 'GO' : 'NO-GO',
      
      criteria: criteria,
      
      reasoning: criteria.zeroConflicts && criteria.noRedefinition ? 
        'Mevcut tasarƒ±m sistemi tutarlƒ± ve √ßakƒ±≈ümasƒ±z. Sadece bo≈üluklarƒ± doldurma i√ßin GO.' :
        '√áakƒ±≈üma veya tutarsƒ±zlƒ±k tespit edildi. D√ºzeltilmeden ekleme yapƒ±lamaz.',
        
      recommendations: [
        'Mevcut ilkeler korunmalƒ±',
        'Sadece eksik alanlar doldurulmalƒ±', 
        'ƒ∞dempotent ekleme prensibi uygulanmalƒ±',
        'Nightly drift kontrol√º aktif edilmeli'
      ]
    };

    console.log(`üìä Karar: **${decision.status}**`);
    console.log(`üìù Gerek√ße: ${decision.reasoning}`);
    console.log('\n‚úÖ Kriterler:');
    Object.entries(criteria).forEach(([key, value]) => {
      console.log(`   ‚Ä¢ ${key}: ${value ? '‚úÖ' : '‚ùå'}`);
    });

    return decision;
  }

  generateReport(decision) {
    console.log('\nüìã Rapor Olu≈üturuluyor...\n');

    // Mevcut audit dosyasƒ±ndan version ve diƒüer bilgileri al (varsa)
    let currentVersion = 'v1.0.0';
    let existingUpdateHistory = null;
    try {
      if (fs.existsSync(this.auditFile)) {
        const existingAudit = JSON.parse(fs.readFileSync(this.auditFile, 'utf8'));
        if (existingAudit.designSystemVersion) {
          currentVersion = existingAudit.designSystemVersion;
        }
        if (existingAudit.updateHistory) {
          existingUpdateHistory = existingAudit.updateHistory;
        }
      }
    } catch (error) {
      console.log('üìù Yeni audit dosyasƒ± olu≈üturuluyor...');
    }

    const report = {
      auditDate: new Date().toISOString(),
      designSystemVersion: currentVersion,
      
      currentPrinciples: this.currentPrinciples,
      
      // Mevcut updateHistory'i koru (varsa)
      ...(existingUpdateHistory && { updateHistory: existingUpdateHistory }),
      
      conflictMatrix: this.conflicts,
      
      gapsIdentified: [
        // Hen√ºz √∂nerilen yeni ilke yok, bu y√ºzden gap yok
        'Bu a≈üamada belirlenmi≈ü gap yok'
      ],
      
      decision: decision,
      
      driftCheck: {
        status: 'clean',
        timestamp: new Date().toISOString(),
        conflicts: 0,
        warnings: []
      },
      
      nextSteps: [
        'Yeni tasarƒ±m √∂nerileri geldiƒüinde bu denetimi tekrarla',
        'Nightly rapora design_drift_check alanƒ±nƒ± ekle',
        'Her PR\'da √ßakƒ±≈üma kontrol√º yap',
        'Versiyon numaralandƒ±rmasƒ± uygula'
      ]
    };

    // Dosyaya kaydet
    const reportsDir = path.dirname(this.auditFile);
    if (!fs.existsSync(reportsDir)) {
      fs.mkdirSync(reportsDir, { recursive: true });
    }
    
    fs.writeFileSync(this.auditFile, JSON.stringify(report, null, 2));
    
    console.log('‚úÖ Tasarƒ±m Drift Denetim Raporu Hazƒ±r:');
    console.log(`   üìÅ Dosya: ${this.auditFile}`);
    console.log(`   üéØ Karar: ${decision.status}`);
    console.log(`   üîç Drift Status: ${report.driftCheck.status}`);
    console.log(`   üìä √áakƒ±≈üma: ${report.driftCheck.conflicts}`);
    
    return report;
  }
}

// CLI √ßalƒ±≈ütƒ±rma
if (require.main === module) {
  const audit = new DesignSystemAudit();
  
  try {
    const decision = audit.performAudit();
    console.log('\nüéâ Tasarƒ±m ƒ∞lkeleri Denetimi Tamamlandƒ±!');
    console.log(`\nüìã √ñzet: ${decision.status} - ${decision.reasoning}`);
    process.exit(0);
  } catch (error) {
    console.error('\n‚ùå Denetim Ba≈üarƒ±sƒ±z:', error.message);
    process.exit(1);
  }
}

module.exports = DesignSystemAudit;
